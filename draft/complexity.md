# 类型复杂度

这个系列是最近在做模型分析的时候总结出来的一套方法。起初在找有没有类似的方法来做类似的事情，但并没有什么收获。虽然有模型复杂度的概念，但那是在统计学和机器学习中用于评价其模型的，跟程序设计中的类型和建模并不能一概而论。目前这套方法仅有我个人在用，与几个朋友私下沟通了下他们也相对认可其中的一些机制。接下来我会按照顺序讲解这套方法的所有相关内容。

开始之前，我们来想这么几个问题。

- 怎么衡量一个建模是否符合实际的业务？
- “组合优于继承”一定正确吗？
- 为什么 Kotlin 和 Java 都在引入封闭类型的特性？
- 为什么 `Map<String, Object>` 是有害的？

接下来我们会引入一套简单的符号系统来表示和计算类型的复杂度，并根据这种方法来计算和评价一个类型、接口或者模型的设计。

## 概念

我们选择尽量以简化的符号来表示一个类型的复杂度，其具体的含义表示以使用该类型能够表示和容纳的数据的量。假设该类型为 `T`，我们用 $P(T)$ 来表示这个复杂度。

我们以 32 位整数类型 `Integer` 为例。这样一个类型可以表示 $2^{32}$ 即 4294967296 个数据。但这种量级的数据我们无论是书写还是使用起来都不太方便，所以直接简化为符号 $i$，作为一个常数。

同样的，表示 Unicode 字符的类型 `Char`、或者 `Long`，都是类似的量级，为了简化符号的复杂度，我们同样以 $i$ 来表示。

也即，这种一般性的标量类型的复杂度，都可以简化为 $i$。

## 几个常量

除了标量复杂度 $i$ 以外，还有几个比较常用的量。

一些量级较小的数据，比如中小字符串/数组的长度、ASCII 字符的数量、一个复合类型中字段的数量或者函数递归栈的深度等，其可能是 $0$ 到一个不是那么大的数量。这种量级的数据，我们也统一简化为常数 $a$。

所以，一个中小型字符串的复杂度

$$
P(String) = P(Char)^{Length(String)} = i^{a}
$$

我们进一步把 $P(String)$ 也简化表示成一个常量，$s$。即

$$
s = i^{a}
$$

除此之外，单元（`Unit`）类型（比如 Java 中的 `null`）因为只有一个特定的值，则可以表示为 $1$：

$$
P(Unit) = 1
$$

而 Bottom 类型的复杂度为 0：

$$
P(\bot) = 0
$$

同理，Top 类型（比如 Java 中的 `Object`）可以表示用来接受一切值，则表示为 $\infty$：

$$
P(\top) = \infty
$$

由此我们可以得到几个量及相关的常数和他们的排序：

$$
0 \lt 1 \lt a \lt i \lt s \lt \infty
$$

同时，对于任意非底类型 `T` 都有：

$$
P(T) \ge 1 \gt 0
$$

## 计算法则

准确的计算法则满足常规的四则运算和乘方等简单法则。这些量级之间可以通过任意运算来组合。但涉及到化简可以有一些更加直接的规则。同时因为无穷量 $\infty$ 无法直接与其他量进行运算，我们会给出比较大小的规则。

### 近似化简规则

当我们做近似化简的时候，低量级的符号可以被高量级吸收。
即：

$$
\begin{aligned}
&a + 1 \rightarrow a \\
&a \times 2 \rightarrow a \\
&i + a \rightarrow i \\
&i \times a \rightarrow i \\
&s + i \rightarrow s \\
&s \times i = i^{a+1} \rightarrow i^{a} = s \\
\end{aligned}
$$

而对于无穷量 $\infty$，则可以吸收任意的量。即 $\forall n \in \{ 0, 1 ... a, i, s \}$

$$
\begin{aligned}
\infty + n &\rightarrow \infty \\
\infty \times n &\rightarrow \infty \\
\end{aligned}
$$

### 极限情况下的化简规则\*

在**某些情况**下，下面的规则适用：
$$2^{a} \rightarrow i $$

在上面的规则中，因为 i 本身就表示的特定二进制位数的标量量级，这项化简符合其定义。

$$a^{a} \rightarrow s $$

上式中，可以看成是特定长度（$a$）的特定量的组合，比如 ASCII 字符串，实际复杂度与 $s$ 相当。
$$
\begin{aligned}
s^{a} &\rightarrow \infty \\
s^{i} &\rightarrow \infty \\
i^{s} &\rightarrow \infty \\
\end{aligned}
$$

上面三条规则由于本身底数和指数都已经达到了一定量级，其所能表示的范围接近于 Top 类型。如序列化成长文本的 JSON 字符串等。

### 无穷大比较法则

除了常规的约简以外，无穷大无法参与跟其他量的计算。但不同系数和次数的无穷大数值，可以比大小。

首先，无穷大大于其他任意量。
即 $\forall n \in \{ 0, 1 ... a, i, s \}$
$$\infty \gt n$$

其次，同次数的无穷大量，系数大的数值大于系数小的。

$$
\begin{aligned}
x \gt y \Rightarrow \\
&x \cdot \infty^{n} \gt y \cdot \infty^{n}
\end{aligned}
$$

不同次数的无穷大量，次数越大其数值越大，系数不影响：

$$
\begin{aligned}
x \gt y \Rightarrow \\
& m \cdot \infty^{x} \gt n \cdot \infty^{y}
\end{aligned}
$$

次数和系数都相同的无穷大量，可以比较其余项的大小：

$$
\begin{aligned}
x \gt y \Rightarrow \\
&m \cdot \infty^{n} + x > m \cdot \infty^{n} + y
\end{aligned}
$$

## 和类型与积类型

### 和类型 Sum Type

假设我们分别有两个类型 `T` 和 `U`，这两个类型通过合并组成类型 `V`：

```typescript
type V = T | U
```

当然也可以是类似 Java 中接口和实现形式：

```java
interface V {}
class T implements V {}
class U implements V {}
```

这样的类型组成形式在代数数据类型中被称作和类型（Sum Type）。大部分编程语言中都可以通过继承、tagged union 或者 variant 来实现。

这个时候类型 `V` 的复杂度 $P(V)$ 即为类型 `T` 和类型 `U` 的复杂度之和。

$$
P(V) = P(T) + P(U)
$$

因为在这种情况下，类型 `T` 能表示的数据，也都可以作为类型 `V` 的数据，而同样类型 `U` 表示的数据也能作为类型 `V` 表示的数据。而此时类型 `V` 所能表示的数据集合正是 `T` 的集合和 `U` 的集合的并集。在不考虑 `T` 类型和 `U` 类型存在相同数据集的情况下，上式是成立的。而在程序场景中，除非 `T` 和 `U` 之间本身存在着这种组成关系，否则不会有相交的情况。

这种数据集合并，复杂度相加的情况，应该也是“和类型”这个名字的来源之一。

### 积类型 Product Type

与和类型类似，积类型则是通过类型的组合，进行复杂度的乘积。

同样假设我们有两个类型 `T` 和 `U`。通过组合组成 `V` 类型。比如 TypeScript 中的元组：

```typescript
type V = [T, U]
```

或者在 Java 场景中：

```java
class T {}
class U {}
class V {
    T t;
    U u;
}
```

这种情况下，`V` 类型的复杂度 $P(V)$ 的复杂度为：

$$
P(V) = P(T) \times P(U)
$$

比如一个由 `Integer` 和 `String` 组成的 `Pair` 类：

```java
class Pair {
    Integer i;
    String s;
}
```

那么他的类型复杂度则是

$$
P(Integer) \times P(String) = i \cdot s
$$

另外一个复杂的例子：

```java
class A {
    Integer a;
}
class B extends A {
    Integer b;
}
class C extends A {
    String c;
}
class D {
    A a;
    B b;
    C c;
}
```

$$
\begin{aligned}
P(A) &= i + P(B) + P(C) \\
P(B) &= i^2 \\
P(C) &= i \cdot s \\
P(D) &= P(A) \times P(B) \times P(C) \\
&= (i + i^2 + i \cdot s) \cdot i^2 \cdot (i \cdot s)
\end{aligned}
$$

化简后得：

$$
\begin{aligned}
P(D) &= i^{4}s + i^{5}s +i^{4}s^{2} \\
&\rightarrow s^{2}
\end{aligned}
$$

仅仅 4 个类组合出来的 $s^{2}$ 的复杂度也是非常夸张的一个值。

## 递归类型的复杂度

我们来看另外一个例子。

```java
class IntList {
    Integer i;
    IntList next;
}
```

如果还是按照前面提及的积类型的算法，可以得出下面这个结果：

$$
P(IntList) = i \times P(IntList)
$$

这个等式成立的条件是 $P(IntLIst)$ 的值为零，这显然不符合实际情况。

但好在因为硬件资源的限制，我们的递归类型并不会无限大，所以同样如字符串长度等一样，我们也给一个常数的限制，即递归的深度，而这个深度也可以近似为常数 $a$。

把深度概念引入以后，第 $n$ 层级深的 `IntList` 的复杂度可以表示为 $P(IntList_{n})$，那么

$$
\begin{aligned}
&P(IntList_{n}) = i \times P(IntList_{n-1})\\
&P(IntList_{1}) = i \times P(null)
\end{aligned}
$$

即，深度为 $a$ 的 `IntList`，其复杂度为：

$$
P(IntList) = i^{a}
$$

这个结果可以应用到所有的具有相似线性递归的结构上。如果一个线性递归类型 T，除去其递归类型外的复杂度为 $n$，则该类型的整体复杂度为：

$$
P(T) = n^{a}
$$

树状递归类型相对会复杂一点。以二叉树为例：

```java
class IntTree {
    Integer i;
    IntTree left;
    IntTree right;
}
```

因为我们要考虑两个分支的复杂度乘积，于是深度为 $n$ 的 `IntTree`，其类型复杂度为：

$$
\begin{aligned}
&P(IntTree_{n}) = i \times P(IntTree_{n-1})^{2} \\
&P(IntTree_{1}) = i \times P(null)^2
\end{aligned}
$$

依次展开递归得：

$$
P(IntTree_{n}) = i^{2^{n}-1}
$$

也就是说，一个递归深度为 $a$ 的二叉树，其类型复杂度为：

$$
P(IntTree) = i^{2^{a}-1}
$$

当然了，这里得 $a$ 表示的是树的深度而不是节点数目。如果换成节点数目，结果是跟线性递归一样的。

## 封闭类型

（感谢 @tofu 为本节提供思路）

我们回过头来看几个问题。

1. 在最初讨论定义的时候，我们直接给出了一个结论——对于任意的非底类型 `T`，$P(T) \ge 1$。但这个时候如果你的 Java 代码中写了一个没有任何实现类的空 interface，前面点的结论对这个 interface 类型是否成立？
2. 在探讨**和类型**与**积类型**的时候，我们给出的了组合**和类型**与**积类型**的一个例子，其中类 B 和 C 是类 A 的子类，于是得出了对应 D 类的复杂度。但 A 类是一个开放类，也即在系统中无论什么时候我们都能对其扩展，添加新的子类，这样进而间接影响到 D 的复杂度。

类型的开放性和封闭性，即意味着你是否可以随时在类型上进行扩展。虽然开放封闭原则（Open-Close Principle，OCP）告诉我们，要对扩展开放，对修改封闭。但这样带来扩展性的同时，也存在类型复杂度提升等问题。

如 Java 等编程语言提供了封闭类型类型的机制，来让我们限制类型的扩展性，保证复杂度在可控范围内。

首先是 final class，即类型是无法被继承扩展。只能通过定义新的类型，让该 final 类型作为积类型的一个因子来实现新的功能。

```java
final class A {}

class B extends A {} // error
```

其次则是在 Java 15 中加入的 sealed class，这种类型可以被扩展，但是需要显式指定扩展类。不能进行任何新的超出被允许的扩展类之外的扩展类型定义。这样就可以充分利用和类型的组合方式，也可以充分限制其扩展范围。

```java
sealed class A permits B, C {}

final class B extends A {}

final class C extends A {}

final class D extends A {} // error
```

当然，为了满足丰富的扩展需求，Java 还是提供了开放这种封闭和限制的策略。任意 sealed 类型的子类，分别可以被声明成以下几种类型：
- `final`：关闭扩展性
- `sealed`：继续保持限制的扩展性，同时需要指定扩展范围
- `non-sealed`：彻底开放扩展性

而在同为 JVM 平台的编程语言 Kotlin 中，对于封闭类型执行的更彻底。未声明开放（open）的类型默认都是关闭扩展的。从这些近几年加入的新特性取舍可以看出，编程语言的设计者其实对于通过封闭类型限制来降低类型复杂度的做法是比较接受的。

## 泛型类型的复杂度

泛型也是一种通用的抽象方式。把与类型不直接相关的结构和行为组合在一起，得到一个参数化的类型。通过把具体的类型应用到这些参数化的类型，我们可以组合出更多满足需要的结构。

> 一些编程语言中，泛型类型的参数不一定是类型，也可以是一些常量（项），这样就增加了泛型所能实现的内容的自由度和复杂度。但在本节中，我们还是集中关注参数仅为类型的简单泛型。更为完善的泛型类型我们会在后面的内容中再做讨论。

通常我们使用一个泛型的时候不需要关注其实现，更多的是如何为其提供泛型参数。

对于一个泛型类型 `G<T, U>`，其类型复杂度显然是直接跟参数 `T` 对应的具体类型和参数 `U` 对应的具体类型相关，而这些具体类型显然可以是任意的。因此我们没办法仅通过一个泛型的类型形参来推断这样一个类型的复杂度。

进一步地，我们是可以给泛型类型的形参进行约束，即限制其可能的行为等，但除非是限制类型是一个封闭类型，否则我们也无法准确找出这种类型的复杂度计算方法。比如：

```java
interface SomeConstraints {}

class G <T extends SomeConstraints> {}
```

由于 `SomeConstraints` 是一个开放类型，可以随时被扩展。因此，`T` 的可能性就是无限的，我们没办法对于这种无限可能性的情况给出 `G` 的复杂度计算方法。

但是当我们面对一个特化之后的泛型类型，所有的一切都是确定的时候，我们可以根据具体类型来对泛型类型的复杂度做计算了。

因此在一个特化的泛型类型 `G<T, U>` 的复杂度，可以由 `T`、`U` 类型的复杂度 $P(T)$、$P(U)$ 通过某种关系得到。即

$$
P(G_{\langle T,U \rangle}) = g(P(T), P(U))
$$

对于一些相对简单的泛型类，如 `Pair<K, V>`，我们可以很容易找到其对应关系 $g$：

$$
P(Pair_{\langle K,V \rangle}) = P(K) \times P(V)
$$

与组合成积类型并没有什么明显的区别。

但稍微复杂一些的类型就没办法这么直接的计算方法与参数对应。比如 `Map<K, V>`，这种时候我们就不得不考虑其具体所表现的行为来推导对应的关系。

### Map 的复杂度

## 为什么不要用 `Map<String, Object>`


## 领域复杂度常量

## 建模复杂度常量
