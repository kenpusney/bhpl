<style>
code {
    color: #a31515;
}
</style>

# 类型复杂度

这个系列是最近在做模型分析的时候总结出来的一套方法。起初在找有没有类似的方法来做类似的事情，但并没有什么收获。虽然有模型复杂度的概念，但那是在统计学和机器学习中用于评价其模型的，跟程序设计中的类型和建模并不能一概而论。目前这套方法仅有我个人在用，与几个朋友私下沟通了下他们也相对认可其中的一些机制。接下来我会按照顺序讲解这套方法的所有相关内容。

开始之前，我们来想这么几个问题。

- 怎么衡量一个建模是否符合实际的业务？
- “组合优于继承”一定正确吗？
- 为什么 Kotlin 和 Java 都在引入封闭类型的特性？
- 为什么 `Map<String, Object>` 是有害的？

接下来我们会引入一套简单的符号系统来表示和计算类型的复杂度，并根据这种方法来计算和评价一个类型、接口或者模型的设计。

<div style="page-break-before: always;" />

# 目录

- [类型复杂度](#类型复杂度)
- [目录](#目录)
- [概念](#概念)
  - [几个常量](#几个常量)
- [计算法则](#计算法则)
  - [近似化简规则](#近似化简规则)
  - [极限情况下的化简规则\*](#极限情况下的化简规则)
  - [无穷大比较法则](#无穷大比较法则)
- [和类型与积类型](#和类型与积类型)
  - [和类型 Sum Type](#和类型-sum-type)
  - [积类型 Product Type](#积类型-product-type)
- [递归类型的复杂度](#递归类型的复杂度)
- [封闭类型](#封闭类型)
- [泛型类型的复杂度](#泛型类型的复杂度)
  - [Map 复杂度的另一种视角](#map-复杂度的另一种视角)
- [为什么不要用 `Map<String, Object>`](#为什么不要用-mapstring-object)
- [业务复杂度常量](#业务复杂度常量)
- [增量建模](#增量建模)
- [实践议题](#实践议题)
  - [软删除该不该加？](#软删除该不该加)
  - [国际化应该怎么做？](#国际化应该怎么做)
  - [订单状态用什么来表示？](#订单状态用什么来表示)
  - [弱模式数据怎么约束？](#弱模式数据怎么约束)
  - [运营规则算不算业务逻辑？](#运营规则算不算业务逻辑)
  - [扩展性需要提前考虑吗？](#扩展性需要提前考虑吗)

<div style="page-break-before: always;" />

# 概念

我们选择尽量以简化的符号来表示一个类型的复杂度，其具体的含义表示以使用该类型能够表示和容纳的数据的量。假设该类型为 `T`，我们用 $P(T)$ 来表示这个复杂度。

我们以 32 位整数类型 `Integer` 为例。这样一个类型可以表示 $2^{32}$ 即 4294967296 个数据。但这种量级的数据我们无论是书写还是使用起来都不太方便，所以直接简化为符号 $i$，作为一个常数。

同样的，表示 Unicode 字符的类型 `Char`、或者 `Long`，都是类似的量级，为了简化符号的复杂度，我们同样以 $i$ 来表示。

也即，这种一般性的标量类型的复杂度，都可以简化为 $i$。

## 几个常量

除了标量复杂度 $i$ 以外，还有几个比较常用的量。

一些量级较小的数据，比如中小字符串/数组的长度、ASCII 字符的数量、一个复合类型中字段的数量或者函数递归栈的深度等，其可能是 $0$ 到一个不是那么大的数量。这种量级的数据，我们也统一简化为常数 $a$。

所以，一个中小型字符串的复杂度

$$
P(String) = P(Char)^{Length(String)} = i^{a}
$$

我们进一步把 $P(String)$ 也简化表示成一个常量，$s$。即

$$
s = i^{a}
$$

除此之外，单元（`Unit`）类型（比如 Java 中的 `null`）因为只有一个特定的值，则可以表示为 $1$：

$$
P(Unit) = 1
$$

而 Bottom 类型的复杂度为 0：

$$
P(\bot) = 0
$$

同理，Top 类型（比如 Java 中的 `Object`）可以表示用来接受一切值，则表示为 $\infty$：

$$
P(\top) = \infty
$$

由此我们可以得到几个量及相关的常数和他们的排序：

$$
0 \lt 1 \lt a \lt i \lt s \lt \infty
$$

同时，对于任意非底类型 `T` 都有：

$$
P(T) \ge 1 \gt 0
$$

<div style="page-break-before: always;" />

# 计算法则

准确的计算法则满足常规的四则运算和乘方等简单法则。这些量级之间可以通过任意运算来组合。但涉及到化简可以有一些更加直接的规则。同时因为无穷量 $\infty$ 无法直接与其他量进行运算，我们会给出比较大小的规则。

## 近似化简规则

当我们做近似化简的时候，低量级的符号可以被高量级吸收。
即：

$$
\begin{aligned}
&a + 1 \rightarrow a \\
&a \times 2 \rightarrow a \\
&i + a \rightarrow i \\
&i \times a \rightarrow i \\
&s + i \rightarrow s \\
&s \times i = i^{a+1} \rightarrow i^{a} = s \\
\end{aligned}
$$

而对于无穷量 $\infty$，则可以吸收任意的量。即 $\forall n \in \{ 0, 1 ... a, i, s \}$

$$
\begin{aligned}
\infty + n &\rightarrow \infty \\
\infty \times n &\rightarrow \infty \\
\end{aligned}
$$

## 极限情况下的化简规则\*

在**某些情况**下，下面的规则适用：

规则一：

$$2^{a} \rightarrow i $$

在上面的规则中，因为 i 本身就表示的特定二进制位数的标量量级，这项化简符合其定义。

规则二：

$$a^{a} \rightarrow s $$

上式中，可以看成是特定长度（$a$）的特定量的组合，比如 ASCII 字符串，实际复杂度与 $s$ 相当。

规则三～五：

$$
\begin{aligned}
s^{a} &\rightarrow \infty \\
s^{i} &\rightarrow \infty \\
i^{s} &\rightarrow \infty \\
\end{aligned}
$$

上面三条规则由于本身底数和指数都已经达到了一定量级，其所能表示的范围接近于 Top 类型。如序列化成长文本的 JSON 字符串等。

## 无穷大比较法则

除了常规的约简以外，无穷大无法参与跟其他量的计算。但不同系数和次数的无穷大数值，可以比大小。

首先，无穷大大于其他任意量。
即 $\forall n \in \{ 0, 1 ... a, i, s \}$
$$\infty \gt n$$

其次，同次数的无穷大量，系数大的数值大于系数小的。

$$
\begin{aligned}
x \gt y \Rightarrow \\
&x \cdot \infty^{n} \gt y \cdot \infty^{n}
\end{aligned}
$$

不同次数的无穷大量，次数越大其数值越大，系数不影响：

$$
\begin{aligned}
x \gt y \Rightarrow \\
& m \cdot \infty^{x} \gt n \cdot \infty^{y}
\end{aligned}
$$

次数和系数都相同的无穷大量，可以比较其余项的大小：

$$
\begin{aligned}
x \gt y \Rightarrow \\
&m \cdot \infty^{n} + x > m \cdot \infty^{n} + y
\end{aligned}
$$

<div style="page-break-before: always;" />

# 和类型与积类型

## 和类型 Sum Type

假设我们分别有两个类型 `T` 和 `U`，这两个类型通过合并组成类型 `V`：

```typescript
type V = T | U
```

当然也可以是类似 Java 中接口和实现形式：

```java
interface V {}
class T implements V {}
class U implements V {}
```

这样的类型组成形式在代数数据类型中被称作和类型（Sum Type）。大部分编程语言中都可以通过继承、tagged union 或者 variant 来实现。

这个时候类型 `V` 的复杂度 $P(V)$ 即为类型 `T` 和类型 `U` 的复杂度之和。

$$
P(V) = P(T) + P(U)
$$

因为在这种情况下，类型 `T` 能表示的数据，也都可以作为类型 `V` 的数据，而同样类型 `U` 表示的数据也能作为类型 `V` 表示的数据。而此时类型 `V` 所能表示的数据集合正是 `T` 的集合和 `U` 的集合的并集。在不考虑 `T` 类型和 `U` 类型存在相同数据集的情况下，上式是成立的。而在程序场景中，除非 `T` 和 `U` 之间本身存在着这种组成关系，否则不会有相交的情况。

这种数据集合并，复杂度相加的情况，应该也是“和类型”这个名字的来源之一。

## 积类型 Product Type

与和类型类似，积类型则是通过类型的组合，进行复杂度的乘积。

同样假设我们有两个类型 `T` 和 `U`。通过组合组成 `V` 类型。比如 TypeScript 中的元组：

```typescript
type V = [T, U]
```

或者在 Java 场景中：

```java
class T {}
class U {}
class V {
    T t;
    U u;
}
```

这种情况下，`V` 类型的复杂度 $P(V)$ 的复杂度为：

$$
P(V) = P(T) \times P(U)
$$

比如一个由 `Integer` 和 `String` 组成的 `Pair` 类：

```java
class Pair {
    Integer i;
    String s;
}
```

那么他的类型复杂度则是

$$
P(Integer) \times P(String) = i \cdot s
$$

另外一个复杂的例子：

```java
class A {
    Integer a;
}
class B extends A {
    Integer b;
}
class C extends A {
    String c;
}
class D {
    A a;
    B b;
    C c;
}
```

对应每个类型的复杂度分别为：

$$
\begin{aligned}
P(A) &= i + P(B) + P(C) \\
P(B) &= i^2 \\
P(C) &= i \cdot s \\
P(D) &= P(A) \times P(B) \times P(C) \\
&= (i + i^2 + i \cdot s) \cdot i^2 \cdot (i \cdot s)
\end{aligned}
$$

化简后得：

$$
\begin{aligned}
P(D) &= i^{4}s + i^{5}s +i^{4}s^{2} \\
&\rightarrow s^{2}
\end{aligned}
$$

仅仅 4 个类组合出来的 $s^{2}$ 的复杂度也是非常夸张的一个值。

<div style="page-break-before: always;" />

# 递归类型的复杂度

我们来看另外一个例子。

```java
class IntList {
    Integer i;
    IntList next;
}
```

如果还是按照前面提及的积类型的算法，可以得出下面这个结果：

$$
P(IntList) = i \times P(IntList)
$$

这个等式成立的条件是 $P(IntLIst)$ 的值为零，这显然不符合实际情况。

但好在因为硬件资源的限制，我们的递归类型并不会无限大，所以同样如字符串长度等一样，我们也给一个常数的限制，即递归的深度，而这个深度也可以近似为常数 $a$。

把深度概念引入以后，第 $n$ 层级深的 `IntList` 的复杂度可以表示为 $P(IntList_{n})$，那么

$$
\begin{aligned}
&P(IntList_{n}) = i \times P(IntList_{n-1})\\
&P(IntList_{1}) = i \times P(null)
\end{aligned}
$$

即，深度为 $a$ 的 `IntList`，其复杂度为：

$$
P(IntList) = i^{a}
$$

这个结果可以应用到所有的具有相似线性递归的结构上。如果一个线性递归类型 T，除去其递归类型外的复杂度为 $n$，则该类型的整体复杂度为：

$$
P(T) = n^{a}
$$

树状递归类型相对会复杂一点。以二叉树为例：

```java
class IntTree {
    Integer i;
    IntTree left;
    IntTree right;
}
```

因为我们要考虑两个分支的复杂度乘积，于是深度为 $n$ 的 `IntTree`，其类型复杂度为：

$$
\begin{aligned}
&P(IntTree_{n}) = i \times P(IntTree_{n-1})^{2} \\
&P(IntTree_{1}) = i \times P(null)^2
\end{aligned}
$$

依次展开递归得：

$$
P(IntTree_{n}) = i^{2^{n}-1}
$$

也就是说，一个递归深度为 $a$ 的二叉树，其类型复杂度为：

$$
P(IntTree) = i^{2^{a}-1}
$$

当然了，这里得 $a$ 表示的是树的深度而不是节点数目。如果换成节点数目，那递归层数就变成了$\log_{2}{a}$，结果是跟线性递归一样的。

<div style="page-break-before: always;" />

# 封闭类型

（感谢 @tofu 为本节提供思路）

我们回过头来看几个问题。

1. 在最初讨论定义的时候，我们直接给出了一个结论——对于任意的非底类型 `T`，$P(T) \ge 1$。但这个时候如果你的 Java 代码中写了一个没有任何实现类的空 interface，前面点的结论对这个 interface 类型是否成立？
2. 在探讨**和类型**与**积类型**的时候，我们给出的了组合**和类型**与**积类型**的一个例子，其中类 B 和 C 是类 A 的子类，于是得出了对应 D 类的复杂度。这个结果就一定是对的吗？

类型的开放性和封闭性，即意味着你是否可以随时在类型上进行扩展。虽然开放封闭原则（Open-Close Principle，OCP）告诉我们，要对扩展开放，对修改封闭。但这样带来扩展性的同时，也存在类型复杂度提升等问题。

如 Java 等编程语言提供了封闭类型类型的机制，来让我们限制类型的扩展性，保证复杂度在可控范围内。

首先是 final class，即类型是无法被继承扩展。只能通过定义新的类型，让该 final 类型作为积类型的一个因子来实现新的功能。

```java
final class A {}

class B extends A {} // error
```

其次则是在 Java 15 中加入的 sealed class，这种类型可以被扩展，但是需要显式指定扩展类。不能进行任何新的超出被允许的扩展类之外的扩展类型定义。这样就可以充分利用和类型的组合方式，也可以充分限制其扩展范围。

```java
sealed class A permits B, C {}

final class B extends A {}

final class C extends A {}

final class D extends A {} // error
```

当然，为了满足丰富的扩展需求，Java 还是提供了开放这种封闭和限制的策略。任意 sealed 类型的子类，分别可以被声明成以下几种类型：
- `final`：关闭扩展性
- `sealed`：继续保持限制的扩展性，同时需要指定扩展范围
- `non-sealed`：彻底开放扩展性

而在同为 JVM 平台的编程语言 Kotlin 中，对于封闭类型执行的更彻底。未声明开放（open）的类型默认都是关闭扩展的。从这些近几年加入的新特性取舍可以看出，编程语言的设计者其实对于通过封闭类型限制来降低类型复杂度的做法是比较接受的。

这里再回过头来看本节开始的两个问题。
- 第一个问题中，空 interface 依然存在无数扩展的可能性，所以依然是要比底类型复杂
- 第二个问题中 A 类是一个开放类，也即在系统中无论什么时候我们都能对其扩展，添加新的子类，这样进而间接影响到 B、C、D 的复杂度。

但是后文为了简化讨论范围，除非有特殊说明，我们不会考虑开放类在示例以外的扩展。并且，封闭类型也是我个人比较推荐广泛使用的。

<div style="page-break-before: always;" />

# 泛型类型的复杂度

泛型也是一种通用的抽象方式。把与类型不直接相关的结构和行为组合在一起，得到一个参数化的类型。通过把具体的类型应用到这些参数化的类型，我们可以组合出更多满足需要的结构。

> 一些编程语言中，泛型类型的参数不一定是类型，也可以是一些常量（项），这样就增加了泛型所能实现的内容的自由度和复杂度。但在本节中，我们还是集中关注参数仅为类型的简单泛型。

对于一个泛型类型 `G<T, U>`，其类型复杂度显然是直接跟参数 `T` 对应的具体类型和参数 `U` 对应的具体类型相关。

因此在一个特化的泛型类型 `G<T, U>` 的复杂度，可以由 `T`、`U` 类型的复杂度 $P(T)$、$P(U)$ 通过某种关系得到。即

$$
P(G_{\langle T,U \rangle}) = g(P(T), P(U))
$$

进一步地，我们是可以给泛型类型的形参进行约束，即限制其可能的行为等，比如：

```java
interface SomeConstraints {}

class G <T extends SomeConstraints> {}
```

但这种限制只是约束了 `T` 类型的范围，并不会影响 `T` 的复杂度。因此也还是可以参数化的来计算。

对于一些相对简单的泛型类，如 `Pair<K, V>`，

```java
class Pair<K, V> {
    K key;
    V value;
}
```

我们可以很容易找到其对应关系 $g$：

$$
P(Pair_{\langle K,V \rangle}) = P(K) \times P(V)
$$

与组合成积类型并没有什么明显的区别。

而更加复杂的泛型类型也一样。比如 `Map<K, V>` 本质上就是一系列 `K` 的值不同的 `Pair<K, V>` 的集合。也就可以算成：

$$
\begin{aligned}
P(Map_{\langle K,V \rangle}) &= [Map_{\langle K,V \rangle}]^{a} \\
& = [P(K) \times P(V)]^{a} \\
& = P(K)^{a} \cdot P(V)^a
\end{aligned}
$$

不过我们也可以从另外一个视角来考虑 `Map` 的复杂度。

## Map 复杂度的另一种视角

上面的计算结果是从实现的角度来考虑 Map 复杂度的。这种情况一定程度上算是能够直观地表示 Map 这种结构的复杂度规模，但也相应的隐藏了一部分潜在的复杂度。

如果我们换一个视角，从 Map 这种结构的行为上来考虑。Map<K, V> 用于关联两种类型，即以 K 类型值为键，以 V 类型为值的映射（这也是 Map 这个名字的由来）。这就意味着，键的复杂度是 $P(K)$，而每一个键可关联的值的复杂度是 $P(V)$。也即，Map 中能够包含的复杂度是 $P(K)$ 个 $P(V)$ 复杂度的值，这些键之间又是组合关系，所以，最终的复杂度是：

$$
\begin{aligned}
P(Map_{\langle K,V \rangle}) &= \underbrace{P(V) \times  ... \times P(V)}_{P(K) \text{ times}} \\
& = P(V)^{P(K)}
\end{aligned}
$$

不过，一旦以这个视角考虑 `Map` 对象，随随便便一个类型都可能导致整个 `Map` 都是无穷的高次幂级复杂度。所以这里只是以此为例展开一下这样一个评估视角，对于 `Map` 的类型复杂度，我们还是按照 `Pair` 的集合这种方式来看待。

<div style="page-break-before: always;" />

# 为什么不要用 `Map<String, Object>`

通过前面的计算方式我们可以发现，`Map` 是一个能够给系统增加额外复杂度的一个结构。我一直坚持这样一个观点：不要随便使用 `Map`，更不要用 `Map<T, Object>`（`T` 可以是任意类型）。因为一旦引入了 `Map<T, Object>`，就意味着这里的类型复杂度加入了完全不可控的无穷量：

$$
P(Map_{\langle T,Object \rangle}) = \infty^{a}
$$

或者用另一种计算方法：
$$
P(Map_{\langle T,Object \rangle}) = \infty^{P(T)}
$$

而动态类型系统里面，因为允许使用者在运行时对数据结构进行动态的调整，大部分对象模型都是基于 `Map<String, Object>` 这个结构，也即相当于是个不可控的无穷的高次幂量级的系统。

另外，很多人在 Java 实践中会选择用某些 JSON 解析框架提供的通用类型 `JSONObject` 来代替 `Map<String, Object>`。这除了把 Java 变成了半个动态类型语言以外，不会带来任何额外的好处。

当然很多人会提到 Java 会在编译期对泛型做类型擦除，实际运行时还都是 `Object`，所以不会有任何影响。但在模型上指定了具体类型，一方面能够省却在代码中频繁检查键值存在和类型校验、转换的问题（这正是“复杂度”所复杂的地方），另外一方面能够以具体的类型更明确的指定上下游的契约，能够同时避免额外的逻辑代码和异常的数据传递。

但是总是会有些人希望能够在具体的类型上额外多加一个相对灵活扩展结构。比如下面这个对象，就一定比 Map<String, Object> 好吗？

```java
class SomeClass {
    Integer i;
    String s;
    Map<String, Object> ext;
}
```

<div style="page-break-before: always;" />

# 业务复杂度常量

为了回答前面提到的问题，我们引入一个新的概念，即业务的复杂度。一个具体的业务模型，在指定的时间，其必然有一个确定的复杂度。我们用常量 $d$ 来表示。

注意，业务复杂度 $d$ 虽然是常量，但这是在特定时间视角下的。而业务是随时都有可能发生变化的，所以从整个业务变化发展的过程来看，不同时间其对应的复杂度 $d$ 也不相同。而当我们在对业务进行建模时，所针对的显然是当时，也即指定时间点的复杂度，是确定的值。

同样的，这个常量 $d$ 表示的是实际业务的情况，并不以系统建模的结果不同而改变。即便系统中所提供的类型完全不符合 $d$ 的业务需求，但实际业务场景中业务需求的复杂度仍然是 $d$。换句话说，这是一个客观事实性的存在，是我们建模所要达成的目标。

当我们用 Map<String, Object> 来对应表示业务模型时，其复杂度是 $\infty^{a}$，而假设我们明确了一部分的业务，能够对部分属性给出确定类型时，可能得到下面这样一个类型：

```java
class SomeClass {
    Integer i;
    String s;
    Map<String, Object> ext;
}
```

我们在此假设 `Integer i` 和 `String s` 确实是业务模型中的一部分。这个时候，在 `SomeClass.ext` 里，其实就只需要承载 $d - i \cdot s$ 的复杂度的业务就好。因为有两个具体的属性已经排除出了这个扩展结构，其对应的复杂度也进而降低到了 $\infty^{a-2}$。

这个时候 SomeClass 的整体复杂度就变成了：

$$
P(SomeClass_{[d]}) = i \cdot s \cdot \infty^{a-2} \lt \infty^{a} = P(Map_{\langle String,Object \rangle})
$$

下标 $_{[d]}$ 表示以业务复杂度 $d$ 的视角来考虑复杂度的情况。注意这里没有做任何近似运算，因为近似化简之后的结果是两者相等。

上式表明，只要我们能够把符合业务需求的模型给具体化，就一定比泛用像 Map<String, Object> 之类的类型复杂度更低。但同时，其实并没有本质上改变太多，因为 Map<String, Object> 类型带来的复杂度还是相似的。

因此回答前文提出的问题，在提取出的属性能够满足业务需求的情况下，类型越具体越好。SomeClass 一定比直接用 `Map<String, Object>` 好。

<div style="page-break-before: always;" />

# 增量建模

前面我们讲过，类型复杂度这套工具是用来评价模型的。而因为模型的复杂度往往非常复杂，所以我们会尽量抽取成特定量级的常量来表示。

本节我们会脱离开具体类型的复杂度，直接从相对宏观的层面来看一下模型复杂度的变化关系。

软件开发的流程，通常是由相关的人员对具体业务进行分析，得到特定的需求，然后再由需求转化成可用的程序模型和代码。中间存在不止一次的沟通和转化，并且有作为媒介的转化产物，即软件需求。

为了方便讨论，我们把需求复杂度 $r$ 和建模复杂度 $m$ 也分别定义成两个常量。同业务复杂度 $d$ 一样，这也是在特定时间点下对需求和建模的评价结果。

最理想的状态是：

$$
m = r = d
$$

即建模恰好满足了需求，并且需求准确无误的描述了业务。

可惜这只是理想状态。一方面业务多变，因而需求也需要跟着变化以适应；另外一方面，沟通简存在信息丢失和误解，会导致这之间有些不同步的信息以至于无法满足复杂度要求。再加上建模过程中可能会因为扩展性的考虑做出一些过度的提前设计，这种纯粹的理想状态根本不能达成。

但一个基本的理想情况还是可以做到的，即：

$$
m \rightarrow r \rightarrow d
$$

建模复杂度趋近于需求复杂度，需求复杂度趋近于领域复杂度。这里趋近于并不只是小于，因为存在误解或者过度设计的情况，也有可能是过于满足业务或者需求的复杂度。

当然这依然是理想的状态。更实际的情况是：

$$
\begin{aligned}
m &\gt r \\ 
r &\gt r_{[d]} \\
r_{[d]} &\lt d
\end{aligned}
$$

从下至上依次可以解读为：
- 业务人员的视角下，需求是永远不满足的；
- 需求分析总是搞出一些虚头巴脑的业务不相关的功能；
- 而开发人员总是为了扩展多做些无用功或者需求之外的内容。

需求不完全满足业务这件事还可以用后续迭代开发来补救。但是需求分析额外带来的无用功能和建模过程中多设计的部分就成了无用功，除了造成资源浪费以外还额外增加了复杂度。

而且更糟糕的一个问题是，建模复杂度 $m$ 从时间维度来看是递增的。通常来说，我们有两种方式来改进一个以后的系统：

1. 增量建模，通过为当前模型添加额外的信息来满足更新的业务需求
2. 系统重写，通过各种方式添加新的模型来替换原有系统

这两个的结果都是 $m$ 的值随着时间推移而增长。如果不增反降，意味着有部分数据被丢掉了，这在实际业务中几乎是不可能有的。

> 如果你非要以 Google 抛弃各种业务的果断来反驳，那么请细考虑下他们抛弃这些业务的时候，对应业务的 $d$ 是否都已经不存在了。如果是对于主营业务，基本就相当于公司没了。
> 
> 这样离奇的变数就不要想着用什么工具来解释了，先考虑能不能拿到裁员补偿才对。

为了避免出现上面那种荒唐的浪费情况，比较好的办法就是最小化地进行需求分析和建模。在满足主线业务流程以后，再通过增量的方式完善。这样尽管一段时间内 $m \lt r \lt d$，但是能够保证业务的正常流转的情况下不太增加系统的复杂度负担。这当然是我个人的观点，仅供参考。

另外，大部分情况下推倒重来跟兼容式的增量完善比，风险要大很多。我可以给你举几个眼前的例子🌰：

| 基础版本     | 革新版本     | 改良版本     |
|--------------|--------------|--------------|
| PHP 5        | PHP 6        | PHP 7        |
| ECMAScript 3 | ECMAScript 4 | ECMAScript 5 |
| Perl 5       | Perl 6       | Perl 7       |

上面这几个编程语言里面，中间那个版本都是尝试重新设计的革新性版本，基本上都没成。反倒是前一个版本的改良版成了他们的后继。

<div style="page-break-before: always;" />

（待续，以下为提纲）

# 实践议题

以下议题只是对某些实践进行讨论，跑出一些我的观点，并非引导到特定结论。仅供参考，实际操作中仍需要权衡考虑。

<div style="page-break-before: always;" />

## 软删除该不该加？

不应该。

提前设计。需求是否有涉及？业务是否会用到？能否有通过其他方式实现的可能？

<div style="page-break-before: always;" />

## 国际化应该怎么做？

国际化不是简单的汉译英。

不同区域的货币种类、本地化的时间展示、这些是业务的扩张带来的需求变更，因此不是简单翻译一下就能直接拿去用的，需要增量建模加上对应的设计。

<div style="page-break-before: always;" />

## 订单状态用什么来表示？

订单状态 21 表示 “已下单，未发货”

十位表示主状态，个位表示子状态。

复杂度低的类型并不一定是好事儿。

最多只有10个主状态吗？一个主状态最多只有10个子状态吗？一定只有两层状态吗？有没有孙子状态？

字符串能同时区分状态和展示信息，但复杂度又远提高了。

枚举，可以限制复杂度，可以充分展示状态信息，但是灵活性低。

<div style="page-break-before: always;" />

## 弱模式数据怎么约束？

弱模式数据在静态类型系统里面怎么表示

能不能自带schema

<div style="page-break-before: always;" />

## 运营规则算不算业务逻辑？

实体上加标签。运行时由运营人员操作标签来控制。

业务逻辑一部分存在于运营规则里面。运营人员维护这一部分知识。

增加了业务对运营人员的依赖，增加了运营人员操作的负担。高薪留店小二。

<div style="page-break-before: always;" />

## 扩展性需要提前考虑吗？

- 提前留好扩展，但是增加了复杂度和风险
- 增量建模，但是降低了响应速度

例子： C++ 和 Java 的语言标准。C++ 里有很多 implementation defined 的内容。