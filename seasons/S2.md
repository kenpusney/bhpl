# 编程语言简史 第二季

# 一 通用目标模拟系统

时间来到 1961 年。

在之前的两年，[FORTRAN](https://mp.weixin.qq.com/s/aVW8uBnFWPWDjd-wuyHUmg)、[LISP](https://mp.weixin.qq.com/s/MerQPInZKb4f8o_CdTbJkw)、[COBOL](https://mp.weixin.qq.com/s/U9O1fEiMChfuLsMmhhXogA) 和 [ALGOL](https://mp.weixin.qq.com/s/kTI3TUh6o5zJuXSRjUcufw) 都经历了相应的迭代和升级，逐渐从理论变成使用性的语言。但是经历了 50 年代这一波的创造以后大家也都憋不住了。随着这些高级语言的应用，也逐渐发现了更多的问题，探索出来了更多的解决方法。

1961 年出现的 GPSS 也是这样一个非常独特的编程语言。与所有大家现在认知中的编程语言所不同，它既不是过程式、也不是函数式，更不是什么之后才出现的新式语法。在更早找不到其所模仿和继承的对象，后期也没有继承了它衣钵的来者。GPSS 就这样独树一帜地撑起了 60 年代编程语言的开端。

GPSS 的全称是 General Purpose Simulation System（通用目标模拟系统）。名字非常的自表意，就是用来模拟离散时间内的系统以及交互。这样的设计目的导致了其整体结构并不是按照常规认知中的编程语言那样通过语句或者表达式来执行命令。

GPSS 像是堆叠乐高方块一样，让建模者把不同功能的“**块**”（block）放置在一起构建成系统。这些块围绕着某些**实体**（或者叫**事务**，transaction）来执行。这些实体会在不同的块间传递，而不同的块可能会修改当前的事务或者影响其他的一些实体。这其实像极了古早时期的面向对象风格：不同的实体（事务）是**对象**，块则是作用在对象上的**方法**，只是这个时期还没有对于面向对象的深入讨论和研究而已。

执行过程中 GPSS 会自动跟踪各种统计数据，然后生成一个标准报表作为输出。不同的实体大致可以分为**资源**、**计算实体**和**统计实体**。**资源**用来模拟实际生活中的一些有限资源；**计算实体**则是如变量、函数和随机生成器等表示实体和其所在环境状态的元素；**统计实体**，比如队列或者表格，则是用来统计相应的信息。

![后期的GPSS软件提供了更丰富的呈现信息](https://imgkr2.cn-bj.ufileos.com/210dee5c-ee38-408b-8ed6-fc589378ec48.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&Signature=7LCCr4jmm2qgEXKoWvabD0tBUV8%253D&Expires=1615911287)


如下面这段程序，就是用来模拟一个理发师一天（480 分钟）所服务的顾客的情况。这里经过统计可以看到整个过程里的顾客等待队列数量、每次服务的平均时间、和大致一天下来能够服务的人数等。

```
SIMULATE ; Define model

    *
    * Model segment 1
    *

    GENERATE 18,6   ; Customer arrive every 18±6 mn
    QUEUE Chairs    ; Enter the line
    SEIZE Joe       ; Capture the barber
    DEPART Chairs   ; Leave the line
    ADVANCE 16,4    ; Get a hair cut in 16±4 mn
    RELEASE Joe     ; Free the barber
    TERMINATE       ; Leave the shop

    *
    * Model segment 2
    *

    GENERATE 480    ; Timer arrives at time = 480 mn
    TERMINATE 1     ; Shut off the run

    *
    * Control cards
    *

    START 1         ; Start one run

END ; End model
```

这里的 `GENERATE`、`QUEUE`、`SEIZE`、`TERMINATE` 等都是不同的 block，来控制对应的 `Chars`（排队椅子）、`Joe`（理发师）等实体。执行一轮下来就可以利用这些实体其统计信息获取到对应的结论。

以现在的角度来看，这是一个非常有特色的 DSL。但在当时是非常具有突破性的。对于早期字符串处理能力都没有多强的通用编程语言来说，要描述这样一段逻辑会异常复杂。而经过 GPSS 简化之后的逻辑则清晰明了。

也因此，GPSS 作为一个没那么强通用性的编程语言，荣列第一届 HOPL 会议（要知道能上这个会议的编程语言真的都是些有着硬实力的）。尽管没有直系继承者，GPSS 作为第一个用作模拟的编程语言，定义了非常多的概念。这些概念在随后系统模拟软件里面都有着深远的影响。

# 二 符号的狂欢

上回我们说到，GPSS 开启了一个新的时代。而在这之后就是一系列超神了的编程语言，他们都个个身怀绝技。

![我也<del>听</del>看出来了](https://files.mdnice.com/tmp/3911/8be669cf-261d-4405-9a88-1c23cda38a80.jpg)

本期的主角 APL 就是其中一个。

APL 是 A Programming Language 的缩写。但这里的 A 不是 ABCD 的 A，所以和几年之后 Ken Thompson 的 B 语言、 Dennis Ritchie 的 C 语言以及 21 世纪 Walter Bright 的 D 语言都没什么关系。A Programming Language 这个名字来自于 Kenneth Iverson 在 50 年代设计的一套用于应用数学的表示方法。而在同名书的序言中说：

> Because an effective notation for the description of programs exhibits considerable syntactic structure, it is called a _programming language_.

于是呢，A Programming Language，意思是“一门编程语言”。中文也很少会有人把他翻译成“A 语言”，更多人会用“APL 语言”。这里我们简单点，还是叫成 APL。

APL 的独特之处也就在于，这本身就是为了数学而设计的一门语言，那他特定的表示方法和语义从根本上就与常规的编程语言不同。

如下面这个操作，从 1-40 里面选择 6 个不重复的随机数：

```
x[⍋x←6?40]
```

没错在 ASCII 字符里面混入了一些奇怪的东西。这正是因为 Kenneth Iverson 努力让 APL 看起来更像数学的一个操作。所以为了能够执行 APL 程序，需要专门设计的编码页和键盘。

![就这堆玩意儿](https://files.mdnice.com/tmp/3911/7b7a0a59-d4b1-4247-9736-30f8de50ba86.png)

这堆符号不仅奇怪，有些还明显与常规（程序员）认知相冲突。比如 APL 的 `2*3` 表示的是 2 的 3 次方，而非 2 和 3 相乘。而对于 `*3`，在绝大多数其他编程语言里面是语法错误，但 APL 里面，如果没有了左侧的底数，默认使用的是自然对数底 $e$，所以整个计算表示的是 $e^3$。

APL 另外一个特别的地方就是对（多维）数组十分友好。默认的操作基本都能应用到单独的数据或者数组上（或者说并没有特殊处理，单独的数据就是只有一个元素的数组而已）。

比如（有缩进的行是 APL 代码，其下一行是这次计算的结果）：

```
   1 + 1
2
   1 2 3 + 1
4 5 6
   1 2 3 + 10 20 30
11 22 33
```

另外，大部分运算符都存在两种用法（像前面提到的情况），对于只有一个参数的操作，叫做 monad（不是[那个 Monad](https://mp.weixin.qq.com/s/r1sTck7kd_rboGBcmc6zgw)），而用于两个参数的操作，叫做 dyad。而这样几乎就用同样多的符号把功能扩张了一倍。

但是操作还不止这一点。如果看过我旧知乎专栏的[Perl 6 系列](https://zhuanlan.zhihu.com/p/35090425 "Perl 6 运算符")，就知道 Perl 6（现在的 Raku）有一些用于组合运算符的复杂操作，可以把原始的功能拓展更多。这种东西早就在近 60 年前设计出来了。

下面的操作就是把 `+` 变成了求和运算：

```
   + / 1 2 3 4
10
```

像 `/` 这种，在 APL 中叫做 Operator，用来组合成新的函数。

早期的 APL 并没有一些控制流语句，但因为有 iota 函数（`ι`），所以对于循环之类的还是可以很轻松的模拟出来。

比如找出从 1 到 R 中质数的程序，可以变成下面这种：

```
(~R∊R∘.×R)/R←1↓ιR
```

嗯老实说脱离了材料我也不知道这些东西到底是怎么写出来的。

直到现在，APL 和其衍生的编程语言在描述计算方面方便的特性仍然让其在各行业发挥余热。但毕竟因为 APL 的那套符号体系和键盘太不接地气。Iverson 又设计出了基于 ASCII 符号和双字符的新语言 J。

这群人真的是不用完 26 个字母不死心。

# 三 与类共舞

身怀绝技的另外一号很快就出现了。

前面提到了 GPSS 这样一个用于离散时间模拟的通用语言。但也正是因为其语法与常规编程语言有些差别，用法上也不太相近，所以也就没能在计算机圈儿流行起来。但是今天的主角其目的与 GPSS 类似，但却成功地革新了整个编程语言世界。

这就是前面我们提到过的 ~~ALGOL with class~~ Simula。

其实整体思路还是一样，Simula 最初也只是想安安静静的做一个用来编写模拟程序的工具，用来模拟一下离散事件系统。在当时最热的编程语言自然是刚刚诞生不久的 ALGOL 60，于是 Kristen Nygaard 和 Robert Bemer 开始想着扩展 ALGOL，让它能够实现离散事件模拟。这在当时并不是什么难事儿，经过三年的研发，Nygaard 和 Bemer 于 1965 年 1 月在 UNIVAC 上实现了 Simula I。

Simula I 并没有“with class”。上一季的读者应该记得，“with class”的是 Simula 67。1966 年 Tony Hoare 实现 ALGOL W 的时候引入**记录（record）类型**的概念，在这基础之上，进一步地，Ole-Johan Dahl 和 Kristen Nygaard 把 record 扩展成了**类**（Class）和**子类**（Subclass）的概念。与之相关的 Paper 成了 Simula 67 的第一版规范。不久之后，尽管 Dahl 尝试合并**类型**（type）和**类**（class）这两个概念的提议被否决，Simula 67 还是在 1968 年 2 月被标准化。

在 Simula I 的基础之上，Simula 67 引入了大量的新概念：**对象**、**类**、**继承**、**子类**、**虚函数**和**协程**（coroutine），并且支持**垃圾回收**。单是对象这一概念，就影响了至今的**所有**面向对象语言。其所创造的虚函数动态分发概念，至今依然是最高效的子类型多态实现方式。并且作为受 Tony Hoare 影响的编程语言，其中的对象和协程概念，也进一步地启发了 Actor 模型的诞生。

这种扩展之下，Simula 67 已然成了一个通用编程语言，于是不只是其所专的模拟程序，在各种行业软件、通信领域、计算机算法和图形处理领域等都遍地开花。

通常我们提起“面向对象”的概念时，都会把这点归功于 Alan Kay 和其创造的 Smalltalk。Simula 这方面所受的关注远不及 Smalltalk，一方面是因为年代实在久远，另一方面也是因为前者其实已经在其领域有所成，不必靠多出来的“面向对象”概念来做推广。在尚未有方法论加持的情况下，Simula 的遗产也早就渗透了现代计算机科学的各个角落。

# 返场：Simula 与面向对象


我一直尽量在[上一篇文章](https://mp.weixin.qq.com/s/9vDaGwoNChWUIyM1D8_jng)中提到面向对象这个概念。因为远在 Simula 出现的年代，这个概念根本都还不存在。所以上一篇文章的标题关键字是“类”而非“对象”。

Alan Kay 在 1997 年的 OOPLSA （80 年代开始的一个讨论面向对象相关话题的国际会议）上提到了，是他造出来的“面向对象”这个词。而即便是这个概念被反复论述，也没有一个准确的定义。反倒是在很长的一段时间内都在被业界用来作为一套营销手段。

> I made up the term 'object-oriented', and I can tell you I didn't have C++ in mind.
>
> -- Alan Kay, OOPLSA '97

Simula 的贡献确实是把基于继承的子类型多态实现了出来，同时给定了类（Class）、子类（Subclass）等多个概念。但毕竟 Simula 的动机还是为了用来构建一个用于模拟的环境。如同我们在 [GPSS](https://mp.weixin.qq.com/s/xeGms3UQW9fj5cLguDoZhA) 中看到的那样，这些操作天生就类似“某实体”进行“某个动作”的过程。在 Simula 里面也就变成了每个类里面不同的过程（procedure）。

这种实用主义的做法与后来类似本体论的“面向对象”宣传有着本质的区别。在 Simula 中，类和对象只是可以更好来实现模拟的一个工具，而到了 Smalltalk（特别是 Smalltalk 80）里，就变成了“**In Smalltalk everything is an object**”。

但是你再看 2003 年 Alan Kay 的表述，是不是还是充满着一股玄学气息。

> OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. _..._
>
> -- Alan Kay, 2003

上面这段话的三个点分别是：

- 消息传递
- 保持、保护和隐藏局部的状态流转
- 最大限度地延迟绑定

完全不是所谓的的“抽象”、“封装”、“继承”和“多态”。

而他这段话还有后半句：

> _..._ It can be done in Smalltalk and in LISP. There are **possibly** other systems in which this is **possible**, but I'm **not aware** of them.
>
> -- Alan Kay, 2003

想来 Alan Kay 也是看累了这个圈子的过度解读，才尝试把自己的想法跟 “other systems” 划清界线吧。

上一篇文章也提到另外一件事，就是 Simula 基于虚函数的动态分发是最高效的子类型多态实现方式。这个表述可能有些问题，毕竟子类型多态并不仅限于基于类继承的这套。但 Simula 这方面的创造至今仍然影响大部分编程语言的设计。连最安全的 Rust 都不得不把虚表和动态分发这套硬生生的自己实现一套。

动态分发才是大部分人使用“面向对象”的场景基础。这样才存在结构和行为的“复用”。诸如前面提到的各种抽象封装等等一系列的概念，换到其他各种编程范式里面都是存在的（比如[【1】](https://mp.weixin.qq.com/s/F-_vBBgOSMGtz21O66NyBQ)、[【2】](https://mp.weixin.qq.com/s/IMBmt1us7igmUrPfxGzpTQ)、[【3】](https://mp.weixin.qq.com/s/-ApGvl21ff9SDuf-TxZ_YQ)、[【4】](https://mp.weixin.qq.com/s/5L9ghmy3SpBNd9Wvf_l6vA)中提及的内容）。

另外，很多时候设计上提供选项和强制必须使用所带来的体验是完全不同的。比如一定程度上继承了 Simula 思路的 C++，在动态分发这一点上选择交给使用者来控制，只有你**指定了某些成员**是虚（**virtual**）的，才存在动态分发的情况。而比如 Java，**基本所有的实例方法都是虚的**，就需要有强大的运行时来做控制和优化。更进一步地对于大多数动态类型编程语言，采取了 Alan Kay 前面提到的“**extreme late-binding**”的方式以后，**所有方法调用都要在运行时再进行解析和分发**，对于一些强实时性和硬件资源有限制的场景，简直就是噩梦。

这里扯这么多不是在说 Alan Kay 或者 Smalltalk 不对，只是澄清一下 Simula、“面向对象”和一些别的概念。恰恰相反 Smalltalk 在他所处的那个时代也是领路者，同时其遗产也被很大一部分编程语言所继承。这个我们后面会细聊。

# 四 雪球与模式匹配

在大部分编程范式都还没有一个定论之前，是编程语言发散和创造的高峰期。这时期我们看到了靠符号组合编程的 APL、靠类和子类来模拟世界的 Simula。而今天要说的这个，给我们带来了模式匹配。

1962 年，AT&T 贝尔实验室的几位大佬开发了 SNOBOL 语言来对多项式进行符号化的处理。其目的非常简单，就是通过符号匹配来解析文本。所以其唯一的数据类型就是文本（字符串）。作为私有语言使用了一段时间后，SNOBOL 开始在一个小群体里扩散开来。随之也带来了一些对其缺陷的反馈和抱怨，于是进行了几次改进之后，加入了自定义函数、更多的数据类型和操作，变成了一个更为完备的编程语言，即 SNOBOL4。

同时为了确保 SNOBOL 的一些高级特性得以实现，SNOBOL4 专门采用了一套虚拟机，和一套与宿主机器无关的虚拟机指令，SIL（SNOBOL Implementation Language）。这极大的提升了 SNOBOL4 的可移植性，只需要在对应的宿主机平台实现这套指令执行引擎就好。数十年后的那个 Write Once, Rewriteun Anywhere 的编程语言也借鉴了这套思路并作为推广标语之一。

与当时同时代的绝大多数编程语言相比，SNOBOL 可谓独具一格。SNOBOL 并没有流行的 FORTRAN 或者 ALGOL 中的控制流结构，而是有一套独有的格式。SNOBOL 中的每条语句都是下面的形式：

```
<标签> <主体> <模式> = <客体> : <跳转>
```

这五个部分都是可选的。通常情况下主体与模式相匹配。如果客体存在，则任何被匹配的部分都会按规则替换成客体。跳转可以是条件跳转，也可以是无条件的直接跳转，其中条件可以是主客体求值成功与失败、模式求值成功与失败、模式匹配成功与失败或者最终赋值成功与失败等。跳转的目标则是指定的标签。

就这样一个简单的规则，通过标签跳转可以实现完全不输于结构化控制流的表达能力（当然反过来也可以，这正是结构化编程所主张的）。

而被 SNOBOL 玩出花来的正是“模式”这个地方。在 SNOBOL 中，模式是第一类值。模式可以是很简单的文本，也可以是非常复杂的结构。SNOBOL 把形式语言中的克林闭包成功实现了，这也成了现代正则表达式的前身。SNOBOL 的模式甚至可以复杂到实现 BNF 语法来解析一门简单的编程语言。

说起来 SNOBOL 这个词，读起来如同“Snowball”（雪球）。但在得到这个名字之前，另有一个更性感的缩写，SEXI（“Symbolic EXpression Interpreter”，符号表达式解释器），发音也跟 Sexy 一致。但毕竟这么露骨放到一群计算机科学家周围总觉得不太合适，所以就改成了与-BOL 语言类似的 SNOBOL（“StriNg Oriented symBOlic Language”，面向字符串的符号语言）。

# 五 Christopher Strachey 与合并的编程语言

如果要问哪个编程语言影响最广泛，那无疑就是国内几乎每个工科学生都躲不掉的 C 语言了。从最底层的系统软件，到工厂里分布的机器中无数的控制软件，到汽车甚至可穿戴装备上的嵌入式系统，到日常所用的云端软件的运行时环境。这个 IT 基建必不可少的工具完美的渗透到了每一个角落。IPv6 的目标是让每一粒沙都拥有自己的物理地址，而如果这粒沙子用的是 TCP/IP 栈，那基本就是 C 语言实现的。

⬆️ 上面这段话，也许真的等到我们聊 C 语言的时候还会再重复一次。因为今天的主角并不是他，而是其“C”字母的来源，C 语言的曾祖父，CPL。

没错跟 APL 一样，CPL 没有把自己变成像是那几个后继者（B 语言、C 语言、D 语言）一样变成**单字母**的名字，尽管他完全有这个实力和资本。CPL 起源于英国的**剑桥大学**。当年的大英凭借着一些深厚的学术实力还没有完全被大西洋对岸的美利坚抢去风头。而 CPL 中的字母 C 就是源自于剑桥的英文 **Cambridge**。后来因为学术交流，变成了伦敦大学与剑桥一起来开发，于是 CPL 的 C 也就从 **Cambridge** 变成了 **Combined**（**合并**了两所大学的资源）

作为一个早期的编程语言，除了提供了 C 语言的命名以外，其实并没有太多特点值得称道。因为在设计上借鉴了 ALGOL 60 和 LISP，CPL 本身的语言标准非常复杂。ALGOL 60 report 只有短短的 16 页，而 CPL 未完成规范的 Working Paper 就有 128 页。也因此相当长的一段时间内，没有完整的编译器实现，只是作为 Strachey 在其讲义中专用的语言。

为什么要提到讲义呢？1967 年 8 月，Strachey 在哥本哈根的**计算机编程国际暑期学校**（International Summer School of Computer Programming）中开了个课。这个课程的讲义就是 _Fundamental Concepts in Programming Languages_（**编程语言中的基本概念**）。

这个课程以及这份讲义听起来很简单，毕竟**基本概念**也就那些东西，CPL 又没什么实质的创新。但作为早期涉及**编程语言理论**的内容，这里基本概念也已经远不止“如何编程”这么简单了，而更多的是关于编程语言和编译器设计相关的内容。

这篇短短 39 页的讲义中，Strachey 介绍了关于**表达式**、**命令**（也即后来的**语句**）等相关元素的**语义**与**求值过程**。并创造性的提出了**左值**（L-value）、**右值**（R-value）、**引用透明性**（reference transparency）、**特设多态**（ad-hoc polymorphism）、**参数化多态**（parametric polymorphism）等众多直到今天还在使用的概念。Strachey 甚至还调侃了一下不同数学流派的人对于编程语言的看法，一下子把本来看起来很简单的概念上升到了哲学高度。

![讲义简明扼要但不失深度，第一张图就把编程语言的概念模型讲清楚了](https://files.mdnice.com/user/3911/fce32391-8c49-401d-ae8c-7eae0cd2ab4e.png)

为纪念 Christopher Strachey 和其为计算机科学所做的贡献，这篇讲义在 2000 年再次重印。在 30 多年后 Strachey 关门弟子 Peter Mosses 为重印版所写序言中，也提到了很关键的问题：因为很长一段时间都没能有一个完整可用的编译器，CPL 这么一个相对冷门的编程语言是影响理解这篇讲义的一个难点。同时也随着 1975 年 Strachey 的辞世，CPL 也渐渐消失在人们的视野中。

但好在 Strachey 所教授的学生们还在，早在 1967 年，同样来自剑桥大学的 Martin Richards 就实现了一个**简化版**的 CPL，命名为 **BCPL**（Basic Combined Programming Language，~~基本合并的编程语言~~）。而这，又是另外一个传奇的开始。

# 六 约翰·冯·诺伊曼的电子数值积分计算机的开放店铺系统


今天我们聊的这门编程语言叫 JOSS。他是 JOHNNIAC Open Shop System 的缩写。而 JOHNNIAC 又是兰德公司（RAND Corporation）研发的早期大型计算机，其全称是 **John** von Neumann **N**umerical **I**ntegrator and **A**utomatic **C**omputer。没错看名字就知道为了致敬**冯·诺伊曼**和**埃尼阿克**（ENIAC）。如果把这个套娃缩写展开，就是我们的标题了。

这个终极套娃为什么要叫 Open Shop System，我们不得而知。但 JOHNNIAC 作为一个早期的支持**分时共享**的大型机系统，JOSS 是其上一个基础部分，可以在不同的终端共享和使用机器的算力。

这里多嘴一句。上一期我们提到了 Christopher Strachey，他除了创造了 [CPL](https://mp.weixin.qq.com/s/_tAk7Wkf2pxy6pjQ-5_inQ) 和早期对编程语言理论的贡献外，**分时系统**的概念也是他在 1950 年代提出来的。JOHNNIAC 和其同时代很多的计算机都采用了这套思路来设计。早期的这些大佬们可真是遍地开花。

正是因为要用在不同的终端，作为一个系统的基础环境，所以 JOSS 发展了一个非常强的特性：**交互式**。你可以在终端直接执行 JOSS 的指令或者编辑代码，以实时完成某些计算或者组合成复杂的程序逻辑。

JOSS 的终端有两种模式：直接模式，即输入指令直接执行；和间接模式，即插入或编辑源码。没错 JOSS 的编辑动作也是通过终端在命令行执行的，而这个编辑的动作就是通过指定对应**行号**来完成。

也即，在终端没有输入行号的时候，JOSS 会默认作为直接模式来执行。如果输入了行号，会存在两种情况：

- 输入了新的行号，会直接按顺序插入到程序代码中
- 输入了已有的行号，则会直接覆盖之前对应行号的代码

如果你对 [Unix 的 ed 编辑器](https://mp.weixin.qq.com/s/1hd8_F4WQr5SQYfnYzKs9w)还有印象的话，应该知道数年后的 Ken Thompson 也是这么干的，估计是受此启发吧。

行号这个神奇的存在除了能标识程序位置方便插入和编辑以外，还能跟 [SNOBOL](https://mp.weixin.qq.com/s/V-aR0uCZ6gpouNmbrDX8RQ) 的标签一样作为跳转到的目标。说到这里可能大家又觉得很熟悉了，没错随后出现的 BASIC 早期就是这么设计的。并且 BASIC 在这方面几乎完全模仿了 JOSS 的思路，以至于早期的小型机和微型计算机上的内置环境都有套 BASIC 的实现。微软也正是因为这个生意起家的，当然这是后话，我们会再提到。

另外，比 BASIC 略强一点的是，JOSS 的行号是分成了两部分的。即以 `x.y` 的形式存在。而这里的前半部分被称为 page 或者 part。JOSS 中有个指令是 `DO part x`，其含义为执行 page 为 `x` 的部分并返回。所以即便没有明显的过程定义，可以直接用这种标号的方式把一段代码表示成过程。

当然了有 `DO` 自然也就有 `DONE`（函数调用返回），同时也就有 `TO`（直接跳转） 等跳转操作。通过组合这些跳转的指令，加上**后置**的条件判断和循环（就是各位会在 Perl 和 Ruby 中见到的那种）等，JOSS 完全可以作为一个通用编程语言来用。

最后要提及的一点，就是 JOSS 在数字表示上的独特之处。任意数字在 JOSS 中是使用一个**整数**的**十进制数幂**来表示，而非当时已经开始广泛使用的浮点数。这就意味着某些数字，比如 $\frac{1}{3}$，就可以被准确地表示为 $3^{-1}$，从而能够精确地计算出 $\frac{1}{3}+\frac{1}{3}+\frac{1}{3}=1$。

# 七 1 号编程语言

我在年初的一篇文章中批评过那些想要实现通用编程语言的想法。但是这事儿吧，并不是没人实现，只是在 1964 年的那个时候计算机科学的应用领域远没有这么广泛，还有可能顾及到各个领域。现在已经完全不是那个刀耕火种随便发明些东西都是大杀器的年代了。那篇文章中已经详述了我的观点，这里不再多说。

今天我们要聊的就是当初那个想要一统**科学计算**（FORTRAN）、**业务编程**（COBOL）和**系统编程**等领域的 1 号编程语言：**PL/I**（后半部分是罗马数字 I，读作 one）。

这是又一个来自蓝色巨人 IBM 的产品，是由一个专门委员会来参与设计的。最初的计算机用户主要是两部分，其中商业用户使用的是 **COBOL** 等**面向业务**的编程语言，学界用户使用的是 **FORTRAN** 等用于**科学计算**的编程语言。IBM 在之后尝试设计一套计算机系统来同时满足这两部分人的需求，于是也必然要求能够提供一个各种用户计算需求的编程语言。

最初 IBM 尝试过扩展自家的 FORTRAN。但毕竟作为真·第一编程语言的 FORTRAN 设计之初并不能那么好的满足商业用户需要。因此委员会决定参照比较轻量的 ALGOL，设计一门新的编程语言。这个编程语言最初被称为 **NPL**（New Programming Language，新编程语言），后来短暂地被叫过 **MPPL**（MultiPurpose Programming Language，多用途编程语言），再之后就改成了一直用到现在的 **PL/I**（Programming Language One，1 号编程语言）。

自此以后 PL/I 一直是 IBM 大型机的标配，所以除了**大型机**能够应用到的环境之外都极少见到其身影。于是作为一门早期的编程语言，PL/I 并没能对后世的编程语言设计有多少影响。但其本身的设计过程因为经过了多次的扩展，为了确保其**语义**的正确和严谨，委员会采用了比较严谨的方式来描述和设计这门编程语言。这一操作进而让大家意识到，通过**形式化验证**来设计软件是一个不错的能够保证程序正确性的方法，进而形成了最早的形式化建模方法：**维也纳开发方法**（Vienna Development Method，VDM）。

PL/I 在软件工程上迈开的不止形式化方法这简单的一小步。

前面说了 IBM 准备设计一套计算机系统来兼顾各种用户，PL/I 只是为其设计的编程语言。这套系统就是知名的 System/360。其首席架构师是 **Gene Amdahl**，项目经理是 **Fred Brooks**。前者提出过决定了并行计算能力上限的**阿姆达尔定律**，后者则是软件工程名著《**人月神话**》和知名论文《**没有银弹**》（其实就是书中的一章）的作者。

《人月神话》这部成书于 1975 年的作品，满是 Brooks 老爷子在 System/360 时代总结下来的经验。但凡提到**软件工程**的历史，都可能要致敬一下这部名著。毕竟这本书最有实力代表软件工程诞生的年代的时候所发生的情况。然而直到这本书出版了 40 多年后的今天，依然还是没能敲醒那群**希望靠人力就能堆出来奇观**的大佛爷。

# 八 基础

今天如果提及一门“跨平台”的编程语言。想必大家都能举出来无数的例子。毕竟在以 C/C++ 为系统级平台的基础之上，随着各种软硬件接口的逐渐统一和丰富，现代编程语言几乎都是能够跨越多个平台来运行和实现各种功能的。

早在五六十年前也不乏这种现象，比如前面我们提到的 SNOBOL，也正是因为其抽象了一套指令系统作为中间层，方便移植到其他平台，因而促使其更好的发展。

但是，迄今为止，所跨平台之广，持续年限之长的编程语言，几乎没有一个能比得过今天我们要提及的这一门：运行在数十亿设备上的 Java 毕竟需要庞大和沉重的运行时，无法触及极底层；C/C++ 虽然能够深入到底层但是灵活性和动态性又远不足；Atwood 定律虽然预言了 JavaScript 渗透各个角落的事实，但其终究资历尚浅，只是搭乘了互联网的春风。

今天我们要聊的这门编程语言，从六十年代的大型机、小型机，到七八十年代的家用机、PC 和 Mac，到游戏主机，到如今还在热销的 Nintendo Switch，到电子词典和计算器，从服务器到浏览器，到桌面脚本，到 Excel 和 Word 中嵌入的自动化宏，以及人教版高中数学的课本上。

没错，就是 BASIC。

## 初学者的全方位符式指令代码

与如今致力于收割各种焦虑人群的培训机构不同，达特茅斯学院的两位教授 John G. Kemeny 和 Thomas E. Kurtz 更希望从根本上能够创造一种适用所有人群的编程语言，让他们来接触计算机、学习各种编程思想。而 BASIC 就是在这套思路下的产物。这名字也是来自一个缩写，全称是 Beginners' All-purpose Symbolic Instruction Code（初学者的全方位符式指令代码）。

当然这条达成的路线并没有现在看起来这么简单。早在 1956 年，Kemeny 教授就设计了 DARSIMCO（Dartmouth Simplified Code）进行类似的尝试，后面升级为了 DOPE，但效果都不太好。随后也尝试过使用 FORTRAN 和 ALGOL 来进行实验，但这些为专业人士设计的工具充满了让普通人难以理解和记忆的诡异符号。于是最终 Kemeny 和 Kurtz 最终决定重新设计一门新的编程语言来干这事儿。

终于在一群人的努力之下，1964 年 5 月，BASIC 的第一版实现了出来。实现团队的其中一个非常重要的人物 Mary Kenneth Keller 是其中唯一的一名女性，也是第一个获得计算机科学博士学位的女性。这在当时整个都是男性群体的学界，是一个突破性的进展。

## 爆发

BASIC 的特色决定了其非常适合入门级使用，同时也就成了早期的计算机必备的系统程序。因其作为一门高级编程语言很适合入门使用，并且又有足够简单和小巧的核心方便实现，所以在 70 年代微型计算机出现以后，随即出现了爆发式的传播和发展。

当然推动其发展所功不可没的角色就是微软公司。第一个微型计算机版本的 BASIC，也是微软的第一个产品，出现在 Altair 8800 上。随后微软把 Basic 移植到了 **MOS 6502** 平台。6502 在七八十年代是几乎所有低成本家用机的必选，一系列的神机包括 **Apple II**、**Commodore 64**、**Atari 2600** 以及——没错——任天堂的**红白机**都是采用了这套硬件。以至于当时大部分的家用机（比如 Commodore 64）在 ROM 中内置 BASIC 成了标配，**雅达利**和**任天堂**也分别推出了其对应平台的卡带和外设。

各位在**文曲星**和**卡西欧**计算器中使用到的 BASIC，也大概率是这一时代版本的变种。

## PC 和 Visual Basic 的时代

作为微软的发家生意，对 Basic 的投入一直在持续。随后与 IBM 合作设计的 PC 平台上加入了功能更加丰富的 GW-Basic 和后来的 QuickBasic，绑定了自家的 DOS 平台。

1991 年随着微软的 Windows 系统逐渐发展，推出了更进一步革新的 Visual Basic。在成功给这个近三十岁的老语言续命的同时，也开创了另外一个传奇。现在距离 Visual Basic 出现也已经 30 年过去了，依然还没有掉出 TIOBE 的前十。同时这样一门编程语言和其变种也因为其易用性被应用在各个角落：Windows 的 **ScriptHost** 支持 VBScript；**IE 浏览器**的 script 标签支持 VBScript；**IIS Web 服务器**支持 VBScript 编写的动态页面（ASP）；**Microsoft Office 应用**中可以通过 VBA 来扩展宏和表单能力。

## 演变历程

50 多年来的发展过程，让 BASIC 有了非常大的变化。如今大部分的变种都已经不需要再指定行号，但这一特性在早期确是必需的，不可省略。也正因此，通常会遇到行号空余不够导致整个程序需要大规模重写的情况。Dijkstra 老爷子当年所吐槽的情形之一便有此。

但随着算力的提升，行号这个必需的标记已经可以由特定行首的标签来代替，于是更进一步地在八十年代演化出了结构化编程的能力。这个时候的 BASIC 更像是现在的非可视化版本，可以用来完成大部分程序性任务。同时期也有很多基于 BASIC 编写的游戏存在，也正是因为这部分能力的提升能够支撑较大规模的程序。

Visual Basic 出现后，更进一步的加入了异常处理和面向对象的能力。Visual Basic 依托于 Windows 系统，既支持桌面级应用的编程，又能够与系统接口交互，极大增加了其适用范围。同时，Visual Basic 能够被编译到一种**中间指令**（P-Code）执行，这也就成就了其便于作为扩展语言适用到不同应用程序中的情况。再加上微软本身一直在坚持的对于 Windows 后向兼容，一度让最后一个非 .net 版本的 Visual Basic 6.0 在其发布的第 18 年荣获 D.I.C.E. 最具影响力技术奖。

去年微软开源了 GW-Basic，并特定说明这部分的代码实际是转译成的 Intel 8088 汇编。由此可见当时的微软实际已经在工程领域有着非常黑科技的实践了。现在转译技术反倒是因为工具链和运行时的落后而不得不出现的一个过渡工具，想想也觉得挺搞笑的。

# 九 大道至简

你所了解的最简单的编程语言是什么？

三组括号就能实现一切的JSFuck？八个基础符号的Brainfuck？还是只有空白符号的Whitespace？

JSFuck的背后是JavaScript那套复杂的动态规则和强大的执行引擎，单独拿出来的话什么都干不了；Brainfuck 虽然是入门级的 Esolang，但八条指令明显可以再简化；至于看上去只有三个符号的Whitespace，其实是用了霍夫曼编码实现了一套比 Brainfuck 还要（相对）复杂的指令系统（毕竟使用了相同的操作但只有 di 和 dah 的摩尔斯码也能传递非常复杂的信息）。

今天我们要说的就是1964年由意大利籍计算机科学家 Corrado Böhm 设计的一门编程语言，P''（P double prime）。他仅用非常简单的规则和四个符号就实现了图灵完备。

Böhm 教授在编程语言方面的工作始于 1950 年。1951 年，还是研究生的 Böhm 发表了一篇论文，其中提出了他所设的一门语言、机器和一套编译方法。与 1950 年前后出现的大部分编译器不同，这是个元循环求值器。也即，这个编译器是使用其所能编译的语言所描述的。

这一下子打开了 Böhm 通往计算模型的大门。其在 1964 年设计出了 P''，仅有四个符号，和非常简单的规则：

P'' 的基础符号是 $\{ R, \lambda, (, ) \}$。语法规则如下：

- $R \in P^{\prime\prime}$, $\lambda \in P$
- $\forall q_{1}, q_{2}: q_{1} \in P^{\prime\prime}, q_{2} \in P^{\prime\prime} \Rightarrow q_{1} q_{2} \in P^{\prime\prime}$
- $\forall q \in P^{\prime\prime} \Rightarrow (q) \in P^{\prime\prime}$
- 仅通过上面三种方式组合出来的程序是 P'' 程序


那么 P'' 的语义也就可以定义出来了。首先， 定义一个带有无限长纸带的图灵机，并且有一个包含 $\{ c_{0}, c_{1}, ..., c_{n} \}$ n+1 个符号的符号表。

- $\alpha$ 是一个断言，即用来表示读写头访问的符号不是 $c_{0}$；$\alpha$ 并不是语言的一部分，但是作为辅助定义语义的状态使用
- $R$ 表示把图灵机的读写头往纸带右侧移动一格
- $\lambda$ 表示把当前读写头里的符号 $c_{i}$ 替换成 $c_{(i+1)\mod (n+1)}$
- $q_{1}q_{2}$ 表示按顺序执行 $q_{1}$ 再执行 $q_{2}$
- $(q)$ 表示在 $\alpha$ 条件下，循环执行 $q$

这里的一些规则听起来像极了 Brainfuck，因为 Brainfuck 的思路就是来自 P''。

如果我们定义几个新的符号：

- $r = \lambda R$
- $r^{\prime} = r^{n}$，即 n 次迭代执行的 $r$。
- $L = r^{\prime} \lambda$

这样 $\{ (,),L,R,r,r^{\prime}\}$ 就分别对应到了 Brainfuck 的六条指令，`[ ] + - < >`。

所以至此，基本具有了 Brainfuck 的所有能力。

但你以为这样就结束了吗？

因为 P'' 中执行循环的两条指令，让 Böhm 关注起了程序的执行流。于是在第二年把流程图的各种结构也简单的做了个抽象，设计了一套符号系统，从而**证明**了单纯由顺序、分支和循环这些基础结构可以组合出任何可计算函数。

这套理论叫做结构化程序理论（Structured program theorem）。也就是几年后开始逐渐被业界注重起来的**结构化编程**范式的理论基础。

但你以为这样就结束了吗？

在折腾完充满状态和流程转换的图灵体系后，Böhm 把他的魔抓伸向了 Lambda 演算。然后在 1985 年通过 Böhm–Berarducci Encoding 证明了代数数据类型（Algebraic Data Type）和二阶 Lambda 演算（System F）同构。

前面这句话包含的信息量有点多，这里就不展开了，哪天抽时间聊下类型理论的时候再看解释下吧。

