(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{371:function(a,e,v){"use strict";v.r(e);var _=v(45),t=Object(_.a)({},(function(){var a=this,e=a.$createElement,v=a._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"atlas-autocode"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#atlas-autocode"}},[a._v("#")]),a._v(" Atlas Autocode")]),a._v(" "),v("p",[a._v("时间退回到 1952 年，我们在第一季最初也提到了五十年代初期有一群先驱的尝试推动了高级语言的出现，其中一个就是来自英国曼彻斯特大学的 Autocode。")]),a._v(" "),v("p",[a._v("虽然后面相当长的一段时间里编程语言的发展线都在大洋彼岸的美国那边，但在欧洲，特别是英国也还是一步步在走自己的路。")]),a._v(" "),v("p",[a._v("随后的 Autocode 逐渐分成了几条线，一边是由剑桥大学数学实验室的 David Hartley 为 EDSCA 2 计算机设计的 EDSAC Autocode，以其强大的源语言诊断能力领先于时代；另外则是同样是剑桥大学设计用于 Titan 计算机的 CPL（参考 S2E05），更是 C 语言的祖宗辈；而在 Autocode 诞生的曼彻斯特大学，则结合了 ALGOL 特性演化成为 Atlas 计算机上的 Atlas Autocode。")]),a._v(" "),v("p",[a._v("Atlas Autocode（以下简称 AA）在 ALGOL 之上做了很多增强，其中之一便是可以直接包含机器码，这样可以在当时紧缺的计算资源和尚不成熟的编译优化过程之上，进行人工的性能调整。这一特性后面也逐渐被很多“系统级”编程语言或者实现所接受，混合底层语言来获得更进一步的优化在后期基本成为了系统编程的主要操作。")]),a._v(" "),v("p",[a._v("作为一门静态强类型的编程语言，AA 加入了复数（complex）类型，以方便电气工程部门用以做相关计算。对于复数的支持，后来绝大部分编程语言选择采用标准库或者是额外的复合数据类型来实现，但也还是有一些编程语言（如 Python、Golang）作为内置类型来支持。")]),a._v(" "),v("p",[a._v("同样为了方便运算，AA 还进一步的简化了乘法的写法，即省略掉乘法运算符（"),v("code",[a._v("*")]),a._v("）。比如 "),v("code",[a._v("3*a")]),a._v("，可以直接写成 "),v("code",[a._v("3a")]),a._v("。而对于 "),v("code",[a._v("ab")]),a._v(" 这种，如果不存在 "),v("code",[a._v("ab")]),a._v(" 这个变量，而 "),v("code",[a._v("a")]),a._v(" 和 "),v("code",[a._v("b")]),a._v(" 都是已定义的，则会解析成 "),v("code",[a._v("a*b")]),a._v("。")]),a._v(" "),v("p",[a._v("另外，毕竟 AA 还是 Autocode 家族的一员，顺便把 Autocode 灵活的语法继承了下来。其中相当知名的就是至今还能在 Perl 和 Ruby 等语言中见到的后置条件：")]),a._v(" "),v("div",{staticClass:"language-aa extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("a = b + c if n > 1\n")])])]),v("p",[a._v("其等同于")]),a._v(" "),v("div",{staticClass:"language-aa extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[a._v("if n > 1 then a = b + c\n")])])]),v("p",[a._v("而且，与更现代的 Perl 和 Ruby 一样，AA 里面也有与"),v("code",[a._v("if")]),a._v("条件相反的"),v("code",[a._v("unless")]),a._v("。")]),a._v(" "),v("p",[a._v("现在看起来要说有什么特别的好处也并不一定，不过在当时的电传打字机上如果发现忘记加了什么条件顺手补一个还是很方便的。")]),a._v(" "),v("p",[a._v("AA 另外知名的一点就是自带了首个 Compiler-Compiler。即其实现包含了一个递归下降的解析器生成器。在至今还没有普及编译期元编程的 2021 年看来，属于是真正的面向语言编程的先驱了。")]),a._v(" "),v("p",[a._v("虽然计算机的商业领域的成就并不如美国，但一直到现在，在英国、在欧洲，高校（比如格拉斯哥大学）和研究机构（比如法国的 INRIA）对学界和工业界的贡献丝毫不弱。这其实一定程度上说明了商业上的成功并不代表技术实力的进步，相反应该更大力度的投入研究增强优势。")]),a._v(" "),v("h1",{attrs:{id:"亿万美元错误"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#亿万美元错误"}},[a._v("#")]),a._v(" 亿万美元错误")]),a._v(" "),v("p",[a._v("1934 年初，查尔斯·安东尼·理查德·霍尔（托尼·霍尔）出生于英属锡兰（现斯里兰卡）的首都科伦坡。由于其父母都是英国人，父亲更是殖民地的公务员，随后托尼·霍尔被安排回了英国读书。在著名的国王公学完成了高中学业以后，顺利的进入了牛津大学墨顿学院学习古典文学和哲学。")]),a._v(" "),v("p",[a._v("本来按照这个路子，霍尔可以顺利的成为一名英国国家系统的公务员，过上无忧无虑的日子，将来还能拿个爵位进到贵族阶层什么的。但毕业在皇家海军服役不久后就重新回到牛津进修，学习统计学。这个时候牛津已经跟隔壁的曼切斯特大学勾搭上开始用 Autocode 教编程了，于是霍尔跟着莱斯利·福克斯学起了编程，与计算机科学结下了不解之缘。")]),a._v(" "),v("p",[a._v("由于在军队服役的时候学习过俄语，霍尔就被英国文化协会外派到莫斯科国立大学做交换学习。1960 年从苏联回来后，在英国一家小公司任职。在任职期间实现了第一套商用版的 ALGOL 60 实现，并顺便发表了一些算法。")]),a._v(" "),v("p",[a._v("随后因为其在工程方面优秀的表现，霍尔被邀请加入 IFIP（国际信息处理联盟），参与 Working Group 2.1（Algorithmic Language and Calculi）的标准化工作。在这里托尼遇到了一个荷兰人和一个瑞士人，会分别成为他的工作伙伴和战友。")]),a._v(" "),v("p",[a._v("ALGOL 60 和后续的版本一直都是由美国和欧洲的计算机科学家组成的委员会来合作设计，所以我们能在后来的 HOPL 会议上看到分成了美国和欧洲两边的代表一起做报告。欧洲这边的团队由霍尔和瑞士人尼古拉斯·沃斯合作开发 ALGOL 60 的后续版本，在经历了几个版本以后，提交了 ALGOL W 作为改进提案。")]),a._v(" "),v("p",[a._v("ALGOL W 提案的改动并不大，无非是增加了一些其他语言中已经出现的东西，比如字符串类型、复数类型，同时引入了引用和记录类型，以及 while 语句。")]),a._v(" "),v("p",[a._v("不知道是不是因为改动太保守了，最终这个提案还是没有被采纳。ALGOL 60 发展到下一阶段的标准是 ALGOL 68，这个被委员会的那个荷兰人都嫌弃的版本并没能往下走太远。加之业界逐渐冒出来的新语言越来越多，也没人再等标注委员会这样的组织来做决定，大家都纷纷自己扩展或者实现新的东西了。ALGOL 就这样慢慢消失在人们的视野。")]),a._v(" "),v("p",[a._v("但是 ALGOL W 的东西还是被保留了下来。")]),a._v(" "),v("ul",[v("li",[a._v("在讲 Simula （"),v("a",{attrs:{href:"https://mp.weixin.qq.com/s/9vDaGwoNChWUIyM1D8_jng",target:"_blank",rel:"noopener noreferrer"}},[a._v("S2E03"),v("OutboundLink")],1),a._v("）的时候我就提到过，Simula 的第一版并没有 with class，而正是因为受了沃斯和霍尔的 ALGOL W 中的记录类型的影响，实现了类和继承，敲开了新时代的大门")]),a._v(" "),v("li",[a._v("ALGOL W 并没有成为下一代的 ALGOL，但沃斯却依然沿着这个模板走了下去，不久之后一门叫做 Pascal 的编程语言出现了，而这个看上去跟 ALGOL W 非常相似的语言后面会接棒 ALGOL 成为接下来很长一段时间的主流")]),a._v(" "),v("li",[a._v("ALGOL W 的众多小改动中引入了一个不起眼的功能，就是引用。而为了保证引用功能能够稳定的工作，需要一个特殊的对象来表示空置的引用，然后霍尔就成功地发明了 null 对象")])]),a._v(" "),v("p",[a._v("时隔四十多年后，2009 年的一次软件会议上，霍尔坦率地表示，因为 null 实现起来太方便了，所以就采用了这个方案，以至于造就了一个亿万元错误（billion-dollar mistake）。")]),a._v(" "),v("p",[a._v("但不要觉得大佬这么说就真的把他的贡献一笔抹杀了。引用和记录这两个类型的出现极大的增强了编程语言的表达能力，在克里斯朵夫·斯特雷奇（CPL 之父，参考 "),v("a",{attrs:{href:"https://mp.weixin.qq.com/s/_tAk7Wkf2pxy6pjQ-5_inQ",target:"_blank",rel:"noopener noreferrer"}},[a._v("S2E05"),v("OutboundLink")],1),a._v("）的教材里特别把这些包含了进去。同样因为在编程语言设计和实现方面的突出贡献，霍尔获得了 1980 年的图灵奖。而霍尔在计算机科学的其他领域也有诸多成就，比如前面提到他在 60 年代初顺便发表的一系列算法，其中就有著名的快速排序算法。")]),a._v(" "),v("p",[a._v("当然霍尔的故事还没有结束，不久之后我们还会再看到他的。")]),a._v(" "),v("h1",{attrs:{id:"接下来的700种编程语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#接下来的700种编程语言"}},[a._v("#")]),a._v(" 接下来的700种编程语言")]),a._v(" "),v("blockquote",[v("p",[a._v("If you see what I mean.")])]),a._v(" "),v("p",[a._v("1966 年，Peter Landin 在《ACM 通讯》上发布了一篇论文，标题就是《接下来的 700 种编程语言》（The Next 700 Programming Languages）。这篇论文中描述了他设计的一门编程语言，ISWIM，并且很成功地如他所描述的那样影响了后续的编程语言，具体数目虽然不太确定，但大大小小的加起来应该不低于三位数。")]),a._v(" "),v("p",[a._v("700 这个数字来自于一个梗，当时的 ACM 期刊上提到，已存在大概有 700 多种编程语言，于是 Landin 就把这个数字拿来作为自己的论文标题。而在论文里面还有一个诡异的数字——1700：")]),a._v(" "),v("blockquote",[v("p",[a._v('A possible first step in the research program is 1700 doctoral theses called "A Correspondence between '),v("em",[a._v("x")]),a._v(" and Church's λ-notation.\"")])]),a._v(" "),v("p",[a._v("这句话在调侃的是他一年前的论文，A Correspondence between ALGOL 60 and Church's Lambda-notation（ALGOL 60 与丘奇 Lambda 演算之间的同构）。这篇论文也正是 ISWIM 的一个基础。")]),a._v(" "),v("p",[a._v("另外一个部分基础，则是 Landin 在 1964 年的论文 The Mechanical Evaluation of Expressions 中设计的 SECD 抽象机。这是一套用于解释数学表达式的抽象模型，其中当然也包含了函数和闭包的求值。于是这个 SECD 抽象机基本上就成了一个函数式编程语言的执行器。")]),a._v(" "),v("p",[a._v("也就是在设计 SECD 机的过程中 Landin 意识到了编程语言和 Lambda 演算之间的同构性，并且进一步的设计出了 ISWIM。显然，是以他之前的理论研究为基础，在 Lambda 演算之上设计出来的。这比单纯是列表操作的 LISP 格局大了可不止一点。")]),a._v(" "),v("p",[a._v("作为一个论文中存在的语言，ISWIM 并没有可用的实现，也正因此后续的编程语言设计在路子上就开了好几条线。不过在论文中还是加入了一些设计细节，比如知名的 where 子句，和与各种块状语法都不同的缩进语法。至今我们能还能够在一些语言中看到类似的结构。")]),a._v(" "),v("p",[a._v("ISWIM 最初设计时并没有强调类型系统，于是其中的发展分支在 Robin Milner 加入了 Hindly-Milner 类型系统后实现了 ML 语言，后发展成为了现在 ML 系语言。ML 系自带造语言的轮子的传统一直都在，所以大大小小的扩展、方言和 DSL 层出不穷，所以 Landin 说的 700 种显然不是夸张（雾）。")]),a._v(" "),v("p",[a._v("另外 ISWIM 最初的设计包含了一部分命令式语言的操作，是通过语法糖来解析成 lambda 演算进行，另外一个发展分支则丢弃掉了命令式的部分，设计成了纯正的（pure）函数式编程语言。因为纯函数式让惰性求值成为了可能，于是这一分支后续出现了 Miranda、Clean 和 Haskell。跌入魔道的万恶之源了属于是。")]),a._v(" "),v("p",[a._v("ISWIM 的名字来自于 "),v("strong",[a._v("I")]),a._v("f you "),v("strong",[a._v("S")]),a._v("ee "),v("strong",[a._v("W")]),a._v("hat "),v("strong",[a._v("I")]),a._v(" "),v("strong",[a._v("M")]),a._v("ean 的缩写，似乎是在玩梗，但现在看更像是一个大预言家在暗中提醒着什么，“你懂我意思吧。”")])])}),[],!1,null,null,null);e.default=t.exports}}]);